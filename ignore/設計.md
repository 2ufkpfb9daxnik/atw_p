# 1) 高レベルアーキテクチャ（選択肢と推奨）

egui + Rust の composer モジュール（速く小さい）


# 2) コンポーネント構成（最小限の分離）

1. **UI 層**（表示・ユーザ操作）
2. **Input Composer（解釈エンジン）**

   * ローマ字／かな入力どちらでも同じインターフェースで扱える。
   * ルールテーブル（外部 JSON/TSV）をロードして Trie に格納。
   * バッファ、状態機械、最長一致、部分確定を実行。
3. **Scoring Engine（スコア計算）**

   * 文字数ベースのスコア（変換後の文字数）を核に、ミス減算などの補正を行う。
4. **Game Engine（お題提供＋モード管理）**

   * ランダム出題 / モード（1分・1時間・カスタム） / escでお題切り替え処理。
5. **Analytics & Replay**

   * ラップ、文字ごとのタイムスタンプ、ミス列、再生可能なイベント列。
6. **Storage & Ranking**

   * SQLite（ローカル）＋オプションでサーバ同期。ランキングは1分/1時間の公式のみ集計。
7. **Settings & Rule Editor**

   * ローマ字テーブルの読み込み・編集。mozcのように設定ファイルを読み込む。

---

# 3) 入力解釈アルゴリズム（詳細：これが核）

目的：任意順次打鍵（Mozc的）を扱い、**打鍵列 → 確定かな列**をリアルタイムに返す。

## データ構造

* **Trie ノード**：`children: map<char, node>`, `rule: optional Rule`
* **Rule**：`input_str`, `output_str`（かな列）、`action`（COMMIT / CONDITIONAL / PARTIAL_REWRITE 等）、`consume`（何文字をバッファから消すか）
* **Buffer**：現在未確定の打鍵列（文字列）
* **State flags**：`after_n`, `possible_sokuon` 等（少数）

## 初期ロード

* ルールファイル（行ベース）を全て Trie に追加。
* すべての揺れ（si/shi, hu/fu, ou/oo 等）を**個別ルール**として入れておく（正規化しない）。

## 処理（キー受け取り時の主ループ：擬似コード）

```
on_key(key):
  buffer += key
  # 1) プレフィックス探索：buffer の全接頭辞でマッチ候補を探す（Trieで）
  candidates = trie.longest_matches(buffer)  # 可能なマッチを長さ降順で取得

  if candidates.empty():
    # buffer 先頭から部分削除して再試行（例: 誤入力処理）
    handle_no_match(buffer)
    return

  # 2) 最長候補を先に検査
  best = candidates[0]  # longest match
  if best.rule.action == COMMIT:
    emit(best.rule.output_str)
    buffer = buffer.substring(best.rule.consume_end) # consume number of input chars
    clear_state_flags_if_needed()
    # 残った buffer があるなら再帰的に処理（連鎖確定）
    if buffer not empty: on_buffer_nonempty()
    return

  if best.rule.action == CONDITIONAL:
    # まだ続き得る（保留）→ 部分確定の可能性があればプレエディット表示だけ
    if buffer_can_extend_to_longer_match(buffer):
      # do not commit, show preedit (仮確定表示)
      preedit = best.rule.output_str  (maybe shown but not emitted)
      set_state_flags_for_rule(best.rule)
      return
    else:
      emit(best.rule.output_str)
      buffer = buffer.substring(best.rule.consume_end)
      return

  if best.rule.action == PARTIAL_REWRITE:
    # 例：先に出した仮定文字を削除して置換
    delete_preceding_chars(best.rule.consume_prev)
    emit(best.rule.output_str)
    buffer = buffer.substring(best.rule.consume_end)
    return
```

### 追加のルール

* **n（撥音）**：`n` は `CONDITIONAL`。次が `a,i,u,e,o,y` の場合は `n` が次音の先頭 `na` 等として扱われる -> 不確定。`nn` または `n'` で強制確定。
* **促音（っ）**：`kk` のような同子音連続なら `kk -> っ + k` のルールを優先。`ch` 系などはテーブルの例外ルールで処理（`tcha` パターンなど）。
* **部分確定（preedit）**：UI には「仮確定」文字列を表示（ユーザに見せる）。ただしゲームのスコアは「emit（実際に確定）」された文字のみカウント。スペースでお題区切りを行うときは未確定バッファを強制確定できる（またはミス扱いにする設定）。

---

# 4) ゲームフロー／お題管理

* お題データ（JSON）形式（1要素＝1文章）：

```json
{
 "id": "00123",
 "text": "吾輩は猫である。",
 "kana": "わがはいはねこである",   // かな変換後表記（機械で一致判定する用）
}
```

* 文字の流れ（流れる文字モード）：UI 層で確定済み文字を左に退避し、未確定の位置は固定（目の位置を固定する設計）。表示列は `漢字仮名交じり` / `かな` / `期待される打鍵列（任意の表記）` の三段表示。

---

# 5) スコアリング設計（公平性）

* **基本スコア** = 変換後の漢字仮名交じり文の文字数
* **ミスペナルティ** = ローマ字/かな入力では `ミス打鍵数` を **1打鍵 = -1 point**。漢直モードはミスカウントしない
* **最終スコア** = max(0, 基本スコア - ミスペナルティ)
* **ランク付け**：

  - 基本スコア（raw） = 確定かな数 - ミス数（上限 0）
  - 等級レベル L を決める関数：

```
L = floor( (raw / S0) ^ p )
```

  - S0：基準スケール（例 50）
  - p：凸性係数（p > 1）。値が大きいほど「上位で敏感」になる。例： p = 1.5 ～ 2.0

- 具体例：
  - raw = 10, S0 = 50, p = 1.5 → L = floor((10/50)^1.5) = floor(0.2^1.5)=0
  - raw = 200, S0 = 50 → L = floor((4)^1.5) = floor(8)=8
  - raw = 250 → L = floor((5)^1.5)=11 → raw 増加 50 の差で L +3。

こうすると低スコア帯は L がほとんど増えない（＝区間大きめ）、高スコア帯ではちょっとの raw 増加で L が増えやすいという性質が得られます（あなたが望む逆方向の補正：慣れた後の小さな進歩をすぐ反映する）。

- パラメータ設計（推奨初期値）
  - S0 = 50（1単位＝おおむね 50 かなで 1レベル域）
  - p = 1.6（程よい凸性。1.0 が線形、2.0 はけっこう凸）
  - 表示：数値スコア（raw）を常に併記、L を「階級ラベル」としてオプション表示。
---

# 6) 解析・分析機能（詳細）

* **イベント記録（Replay）フォーマット**（例、JSON）

```json
{
 "session_id":"s123",
 "mode":"1min",
 "start_time":"2025-11-02T08:00:00Z",
 "events": [
   {"t": 0.120, "type":"key", "key":"k"},
   {"t": 0.220, "type":"key", "key":"y"},
   {"t": 0.232, "type":"emit", "char":"き"},
   {"t": 1.001, "type":"mistake", "key":"x"},
   ...
 ],
 "score": 123,
 "mistakes": 5,
 "kana_emitted_count": 128
}
```

* **解析ダッシュボード**：10秒ラップ、5文字スパンでの平均、最速/最遅想定持続スコア（理論値）を計算（最速＝現在の最高ラップを永続化した場合、最遅＝最低ラップを永続化した場合）。
* **苦手分析**：各お題（ID）ごとの平均スコア・ミス率・所要時間を統計。一定閾値を越えたものを「苦手リスト」に追加し、専用練習モードで重点学習。閾値はユーザ設定。

---

# 7) ランキング／保存／プライバシー

* **ローカル保存**：SQLite にすべてのセッションを保存（検索・集計が容易）。
---

# 8) UI/UX 指針（要点）

* 三段表示（漢字文／かな／期待打鍵列），常に次の2キー分のキーガイドを提示。
* 未確定（preedit）は強い色、確定分は薄い色。
* 設定で「目標スコア表示 ON/OFF」「経過ラップ ON/OFF」などを切替。
* 流れる文字モード：打鍵中の軸をずらさないように、未確定先頭位置を固定して右から左へ“押し出す”アニメーション。
* リプレイ：可視化（キー毎に色分け、ミスは赤）＋再生速度スライダー。

---

# 9) テストと検証

* **ユニットテスト**：composer に対して網羅的なテストセット（`input sequence -> emitted kana sequence`）。Mozc のテーブルをサンプルとして利用し、動作一致を確認すれば信頼性が高まる。
* **Fuzz テスト**：ランダム入力列で壊れないか、バッファ上限超過の扱いをチェック。
* **ユーザーテスト**：既存のタイピスト（タイプウェル経験者）に AB テストで比較してもらう。

---

# 10) データ（お題）収集方針

* JIS第1水準漢字ベースの硬めテキスト（約3000）＋SNS風ラフテキスト（約3000）＝合計6000案は妥当。
* 追加：ユーザ生成（コミュニティ共有）で拡張可能。jsonファイルを直で書いてもらう。
* 各お題に `kana` を付けておく（判定用）。`kana` は機械的に生成してから人手で検査するワークフローが実用的。

---

# 11) 追加の運用設計

* **苦手ワード自動抽出**：過去 N セッションで誤答率が高いお題を自動的に候補にする。
* **チャレンジ／実績**：日次連続ログインや特定スコア到達でバッジ付与（モチベーション向上）。
* **エクスポート**：履歴の CSV/JSON 出力、動画キャプチャ（リプレイ→動画変換）機能。

---

# 12) 開発プラン（短期でやること）

1. Composer モジュールのプロトタイプ（コア機能：Trie, buffer, 最長一致, preedit, emit） — (1–2 週)
2. 簡易 eguiで1画面プロトタイプ（流れるテキストモード含む） — (1–2 週)
3. スコア・記録保存・簡易解析（ラップ、ミス数）を実装 — (1–2 週)
4. お題データ投入 + ユーザテスト → 微調整
---

# 付録：小さめの設計補助（ルール／Trie の JSON 例）

```json
[
  {"input": "kya", "output": "きゃ", "action": "COMMIT", "consume": 3},
  {"input": "k",   "output": "",   "action": "CONDITIONAL", "consume": 0},
  {"input": "nn",  "output": "ん", "action": "COMMIT", "consume": 2},
  {"input": "n",   "output": "ん", "action": "CONDITIONAL", "consume": 1}
]
```
